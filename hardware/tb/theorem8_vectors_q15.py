#!/usr/bin/env python3
# SPDX-License-Identifier: LicenseRef-QuantoniumOS-Claims-NC
"""Theorem 8 Option A vectors (Q1.15) for hardware energy-dump verification.

Contract (Option A)
-------------------
- Hardware computes canonical RFT outputs y = U_phi^H x (or equivalent).
- Hardware dumps coefficient energies |y[k]|^2.
- Host computes K99 + mean gap + bootstrap CI + pass/fail.

This script generates deterministic golden-drift ensemble inputs (as defined
in `algorithms.rft.core.transform_theorems.golden_drift_ensemble`) in a format
that is easy for SystemVerilog $readmemh to load.

Memory layout (sequential 16-bit words)
--------------------------------------
WORDS_PER_CASE = 2*N
  case base + [0..N-1]      : x_real[n] in signed Q1.15
  case base + [N..2N-1]     : x_imag[n] in signed Q1.15
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import List

import numpy as np

from algorithms.rft.core.transform_theorems import golden_drift_ensemble


@dataclass(frozen=True)
class CaseMeta:
    case_id: int
    scale: float


def _float_to_q1_15(value: float) -> int:
    """Convert float in ~[-1,1] to signed 16-bit Q1.15."""
    scale = (1 << 15) - 1  # map 1.0 -> 0x7FFF
    scaled = int(np.round(float(value) * scale))
    if scaled > 32767:
        scaled = 32767
    if scaled < -32768:
        scaled = -32768
    return scaled

def generate_cases(N: int, M: int, seed: int) -> tuple[np.ndarray, List[CaseMeta]]:
    rng = np.random.default_rng(seed)
    signals = golden_drift_ensemble(N, M, rng)

    # Keep inputs within Q1.15 dynamic range.
    # Scaling cancels in K99 because energies are normalized.
    metas: List[CaseMeta] = []
    for i in range(M):
        peak = float(np.max(np.abs(signals[i])))
        scale = 1.0
        if peak > 0.95 and peak > 0.0:
            scale = 0.95 / peak
            signals[i] = signals[i] * scale
        metas.append(CaseMeta(case_id=i, scale=float(scale)))

    return signals, metas


def write_memh_q15(signals: np.ndarray, out_path: Path) -> None:
    out_path.parent.mkdir(parents=True, exist_ok=True)
    M, N = signals.shape
    words_per_case = 2 * N

    with out_path.open("w", encoding="utf-8") as f:
        f.write("// Theorem 8 Option A: Golden drift ensemble inputs (Q1.15)\n")
        f.write("// Generated by hardware/tb/theorem8_vectors_q15.py\n")
        f.write(f"// N={N}, cases={M}\n")
        f.write(f"// WORDS_PER_CASE={words_per_case} (real[N], imag[N])\n")
        f.write("// Layout per case:\n")
        f.write("//   base+0..base+N-1      : x_real[n] Q1.15\n")
        f.write("//   base+N..base+2N-1     : x_imag[n] Q1.15\n")

        for case_id in range(M):
            x = signals[case_id]
            for n in range(N):
                w = _float_to_q1_15(float(np.real(x[n])))
                f.write(f"{(w & 0xFFFF):04X}\n")
            for n in range(N):
                w = _float_to_q1_15(float(np.imag(x[n])))
                f.write(f"{(w & 0xFFFF):04X}\n")


def write_metadata(metas: List[CaseMeta], out_path: Path, N: int, seed: int, a_min: float, a_max: float) -> None:
    payload = {
        "theorem": "Theorem 8 Option A (hardware energy dump)",
        "date_context": "2026-02-06",
        "N": int(N),
        "num_cases": int(len(metas)),
        "seed": int(seed),
        "ensemble_spec": {
            "generator": "algorithms.rft.core.transform_theorems.golden_drift_ensemble",
            "note": "Signals may be per-case scaled to avoid Q1.15 saturation (scale recorded).",
        },
        "cases": [
            {"id": m.case_id, "scale": m.scale}
            for m in metas
        ],
    }
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(payload, indent=2) + "\n", encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--N", type=int, default=8)
    parser.add_argument("--cases", type=int, default=100)
    parser.add_argument("--seed", type=int, default=42)
    parser.add_argument("--out-memh", type=str, default="theorem8_vectors_N8_q15.memh")
    parser.add_argument("--out-json", type=str, default="theorem8_vectors_N8_q15.json")
    args = parser.parse_args()

    signals, metas = generate_cases(args.N, args.cases, args.seed)
    write_memh_q15(signals, Path(args.out_memh))
    write_metadata(metas, Path(args.out_json), N=args.N, seed=args.seed, a_min=0.0, a_max=0.0)

    print(f"Wrote: {args.out_memh}")
    print(f"Wrote: {args.out_json}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
